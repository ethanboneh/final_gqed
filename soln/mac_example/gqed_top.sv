module gqed
#(
  parameter SEQ_LEN = 32, 
  parameter RESP_BOUND = 3
)
(
  input logic clk, 
  input logic rst,
  input logic [8:0] bmc_in [0:SEQ_LEN-1], // sequence of input generated by the solver. 8 bit data + 1 bit action
  input logic [$clog2(SEQ_LEN)-1:0] i, // index of action under verification 
  input logic bmc_in_valid_2, // BMC chooses when input to second copy is valid
  input logic [8:0] bmc_in_invalid // value chosen by solver for input for when input valid is low  
);

  // 3 copy instantiation
  logic in_valid_1;
  logic in_action_1;
  logic [3:0] in_data_a_1; 
  logic [3:0] in_data_b_1;
  logic out_valid_1;
  logic [7:0] out_data_1;

  mac c1(
    .clk(clk), 
    .rst(rst), 
    .in_valid(in_valid_1), 
    .in_action(in_action_1), 
    .in_data_a(in_data_a_1), 
    .in_data_b(in_data_b_1), 
    .out_valid(out_valid_1), 
    .out_data(out_data_1)
  );

  logic in_valid_2;
  logic in_action_2;
  logic [3:0] in_data_a_2; 
  logic [3:0] in_data_b_2;
  logic out_valid_2;
  logic [7:0] out_data_2;

  mac c2(
    .clk(clk), 
    .rst(rst), 
    .in_valid(in_valid_2), 
    .in_action(in_action_2), 
    .in_data_a(in_data_a_2), 
    .in_data_b(in_data_b_2), 
    .out_valid(out_valid_2), 
    .out_data(out_data_2)
  );

  logic in_valid_3;
  logic in_action_3;
  logic [3:0] in_data_a_3; 
  logic [3:0] in_data_b_3;
  logic out_valid_3;
  logic [7:0] out_data_3;

  mac c3(
    .clk(clk), 
    .rst(rst), 
    .in_valid(in_valid_3), 
    .in_action(in_action_3), 
    .in_data_a(in_data_a_3), 
    .in_data_b(in_data_b_3), 
    .out_valid(out_valid_3), 
    .out_data(out_data_3)
  );

  // input assignments
  logic [$clog2(SEQ_LEN):0] cntr_1, cntr_2, cntr_3; 
  always @(posedge clk) begin
    if (rst) begin
      cntr_1 <= 0;
      cntr_2 <= 0;
      cntr_3 <= 0;
    end else begin
      if (cntr_1 < i) begin // copy 1 should execute up to and not including auv
        cntr_1 <= cntr_1 + 'b1;
      end
      if (in_valid_2 && cntr_2 < SEQ_LEN) begin // copy to executes entire input seuqence
        cntr_2 <= cntr_2 + 'b1;
      end
      if (cntr_3 < 1) begin // copy 3 should execute only auv (counter should count up to i+1)
        cntr_3 <= cntr_3 + 'b1;
      end
    end
  end
  
  assign in_valid_1  = (cntr_1 < i)? 'b1 : 'b0;
  assign in_action_1 = (cntr_1 < i)? bmc_in[cntr_1][8]   : 'b0;
  assign in_data_a_1 = (cntr_1 < i)? bmc_in[cntr_1][7:4] : 'b0;
  assign in_data_b_1 = (cntr_1 < i)? bmc_in[cntr_1][3:0] : 'b0;

  assign in_valid_2  = (cntr_2 < SEQ_LEN)  ? bmc_in_valid_2: 'b0;
  assign in_action_2 = (in_valid_2)? bmc_in[cntr_2][8]   : bmc_in_invalid[8];
  assign in_data_a_2 = (in_valid_2)? bmc_in[cntr_2][7:4] : bmc_in_invalid[7:4];
  assign in_data_b_2 = (in_valid_2)? bmc_in[cntr_2][3:0] : bmc_in_invalid[3:0];

  assign in_valid_3  = (cntr_3 == 0)? 'b1 : 'b0;
  assign in_action_3 = (cntr_3 == 0)? bmc_in[i][8]   : 'b0;
  assign in_data_a_3 = (cntr_3 == 0)? bmc_in[i][7:4] : 'b0;
  assign in_data_b_3 = (cntr_3 == 0)? bmc_in[i][3:0] : 'b0;

  // arch state assumption
  logic [$clog2(RESP_BOUND):0] c1_idle_cntr; // needs to count up to RESP bound
  logic [7:0] final_arch_st_1;
  logic [7:0] init_arch_st_3;
  logic arch_st_done;
  always @(posedge clk) begin
    if (rst) begin
      c1_idle_cntr    <= 0;
      final_arch_st_1 <= 0;
      init_arch_st_3  <= 0;
      arch_st_done    <= 0;
    end else begin
      if (cntr_1 == i && c1_idle_cntr < RESP_BOUND) begin
        c1_idle_cntr <= c1_idle_cntr + 'b1;
      end
      if (c1_idle_cntr == RESP_BOUND) begin
        final_arch_st_1 <= c1.ACC;
        arch_st_done <= 'b1;
      end
      if (cntr_3 == 0) begin
        init_arch_st_3 <= c3.ACC;
      end
    end
  end

  SAME_ARCH: assume property (@(posedge clk) (arch_st_done implies (final_arch_st_1 == init_arch_st_3)) );

  //FC check:
  logic c1_done, c2_done, c3_done;
  logic [$clog2(SEQ_LEN):0] out_cntr_2; 
  logic [7:0] c2_out, c3_out; 
  always @(posedge clk) begin
    if (rst) begin
      c1_done    <= 'b0;
      c2_done    <= 'b0;
      c3_done    <= 'b0;
      out_cntr_2 <= 'b0;
    end else begin
      if (out_valid_2) begin
        out_cntr_2 <= out_cntr_2 + 'b1;
      end
      if (c1_idle_cntr == RESP_BOUND) begin
        c1_done <= 'b1;
      end
      if (out_cntr_2 == i && out_valid_2) begin
        c2_done <= 'b1;
        c2_out  <= out_data_2;
      end
      if (out_valid_3) begin
        c3_done <= 'b1;
        c3_out <= out_data_3;
      end
    end
  end
  FC: assert property( @(posedge clk) ( (c1_done && c2_done && c3_done) implies (c2_out == c3_out) ) );

  STABLE: assume property ( @(posedge clk) ( $stable(bmc_in) && $stable(i) ) );

  // Auxillary:
  // Example of a cover property
  COVER: cover property (@(posedge clk) i == 3 && c1_done && c2_done && c3_done);
  
endmodule





